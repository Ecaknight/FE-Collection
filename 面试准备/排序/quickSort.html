<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>快速排序</title>
</head>
<body>
    <p>
        通过⼀趟排序将待排记录分隔成独⽴的两部分，其中⼀部分记录的关键字均⽐另⼀部分的关键字
⼩，则可分别对这两部分记录继续进⾏排序，以达到整个序列有序。
    </p>
    <ul>
        1.从数组中选择中间⼀项作为主元；
        2.创建两个指针，左边⼀个指向数组的第⼀项，右边指向数组最后⼀项。移动左指针直到我们找到⼀个⽐主元⼤的元
        素，接着，移动右指针直到找到⼀个⽐主元⼩的元素。然后交换它们，重复这个过程，直到左指针超过了右指针。这个
        过程是的⽐主元⼩的值都排在了主元之前，⽽⽐主元⼤的值都排在了主元之后，这⼀步叫划分操作。
        3.接着，算法对划分的⼩数组（较主元⼩的值组成的⼦数组，以及较主元⼤的值组成的⼦数组）重复之前的两个步骤，
        直⾄数组以完全排序。
    </ul>
</body>
</html>
<script>
    function compare (a, b) { // 简单的比较方法
        if (a === b) {
            return 0
        }
        return a < b ? -1 : 1
    }

    function swap (arr, a, b) {
        [arr[a], arr[b]] = [arr[b], arr[a]]
    }

    // 分治函数
    function partition (arr, left, right) {
        var pivot = arr[Math.floor((left + right) / 2)]
        var i = left
        var j = right
        while (i <= j) {
            while (compare(arr[i], pivot) === -1) {
                i++
            }

            while (compare(arr[j], pivot) === 1) {
                j--
            }

            if (i <= j) {
                swap(arr, i, j)
                ++i
                --j
            }
        }
        return i
    }

    function quick (arr, left, right) {
        var index = -1
        if (arr.length > 1) {
            index = partition(arr,left, right)
            if (left < index - 1) {
                quick(arr, left, index - 1)
            }
            if (right > index) {
                quick(arr,index, right)
            }
        }
        return arr
    }

    function quickSort (arr) {
        return quick(arr, 0, arr.length - 1)
    }

    var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
    console.log(quickSort(arr))
</script>
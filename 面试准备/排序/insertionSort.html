<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>插入排序</title>
</head>
<body>
    <p>
        是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
        插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），
        因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
    </p>
    <1>.从第一个元素开始，该元素可以认为已经被排序；
    <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；
    <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；
    <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
    <5>.将新元素插入到该位置后；
    <6>.重复步骤2~5。
</body>
</html>
<script>
    function insertionSort (arr) {
        console.time('1-');
        for (var i = 1, len = arr.length; i < len; i++) {
            var key = arr[i]
            var j = i - 1
            while (j >= 0 && arr[j] > key) { // 将在比key大的数往后移，
                arr[j + 1] = arr[j]
                j--
            }
            // 也可以理解为在上面arr[j+1]= arr[j] 移动操作中，导致了arr[j+1]空出来了
            arr[j + 1] = key // 这里要+1，原因是j在之前--操作，导致位置往前移多一个位置
        }
        console.timeEnd('1-');
        return arr
    }
    var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
    console.log(insertionSort(arr));

    // 改进版--二分查找
    function insertionSort2 (arr) {
        console.time('二分插入排序耗时：');
        for (var i = 1, len = arr.length; i < len; i++) {
            var key = arr[i], left = 0, right = i - 1
            // 二分查找， 逼近插入的位置
            while (left <= right) {
                var middle = parseInt((left + right) / 2)
                if (key < arr[middle]) {
                    right = middle - 1
                } else {
                    left = middle + 1
                }
            }

            for (var j = i - 1; j >= left; j--) {
                if (arr[j] > key) {
                    arr[j + 1] = arr[j]
                }
            }
            arr[left] = key
        }
        console.timeEnd('二分插入排序耗时：');
        return arr
    }
    console.log(insertionSort2(arr));
</script>
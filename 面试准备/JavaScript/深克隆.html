<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    /**
     * ！浅拷贝
     * 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
     * 如果属性是基本类型，拷贝的就是基本类型的值，
     * 如果属性是引用类型，拷贝的就是内存地址 ，
     * 所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
     * 
     * 深拷贝：
     * 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,
     * 且修改新对象不会影响原对象
    */
    const mapTag = '[object Map]';
    const setTag = '[object Set]';
    const arrayTag = '[object Array]';
    const objectTag = '[object Object]';
    const argsTag = '[object Arguments]';

    const boolTag = '[object Boolean]';
    const dateTag = '[object Date]';
    const numberTag = '[object Number]';
    const stringTag = '[object String]';
    const symbolTag = '[object Symbol]';
    const errorTag = '[object Error]';
    const regexpTag = '[object RegExp]';
    const funcTag = '[object Function]';

    const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];

    function isObject(target) {
        const type = typeof target
        return target !== null && (type === 'object' || type === 'function')
    }

    function getType(target) {
        return Object.prototype.toString.call(target)
    }

    function getInit(target) {
        const Ctor = target.constructor
        return new Ctor()
    }

    function cloneSymbol(targe) {
        return Object(Symbol.prototype.valueOf.call(targe));
    }

    function cloneReg(targe) {
        const reFlags = /\w*$/;
        const result = new targe.constructor(targe.source, reFlags.exec(targe));
        result.lastIndex = targe.lastIndex;
        return result;
    }

    function cloneFunction(func) {
        const bodyReg = /(?<={)(.|\n)+(?=})/m;
        const paramReg = /(?<=\().+(?=\)\s+{)/;
        const funcString = func.toString();
        if (func.prototype) {
            const param = paramReg.exec(funcString);
            const body = bodyReg.exec(funcString);
            if (body) {
                if (param) {
                    const paramArr = param[0].split(',');
                    return new Function(...paramArr, body[0]);
                } else {
                    return new Function(body[0]);
                }
            } else {
                return null;
            }
        } else {
            return eval(funcString);
        }
    }

    function cloneOtherType(targe, type) {
        const Ctor = targe.constructor;
        switch (type) {
            case boolTag:
            case numberTag:
            case stringTag:
            case errorTag:
            case dateTag:
                return new Ctor(targe);
            case regexpTag:
                return cloneReg(targe);
            case symbolTag:
                return cloneSymbol(targe);
            case funcTag:
                return cloneFunction(targe);
            default:
                return null;
        }
    }

    function forEach(arr, iteratee) {
        let index = -1
        const len = arr.length
        while (++index < length) {
            iteratee(arr[index], index)
        }
        return arr
    }

    // 使用WeakMap是因为为弱引用，能够在使用完成后被回收
    function clone(target, map = new WeakMap()) {
        // 原始类型返回
        if (!isObject(target)) {
            return target
        }

        // 初始化获取参数类型，不同类型处理不同
        const type = getType(target)
        let cloneTarget
        if (deepTag.includes(type)) {
            // 构建实例，这里通过它的构造函数来构建，不影响原来的原型对象
            cloneTarget = getInit(target, type)
        } else {
            return cloneOtherType(target, type)
        }

        // 防止循环引用
        if (map.get(target)) {
            return map.get(target)
        }
        map.set(target, cloneTarget)

        if (type === setTag) {
            target.forEach(value => {
                cloneTarget.add(clone(value, map))
            })
            return cloneTarget
        }

        if (type === mapTag) {
            target.forEach((value, key) => {
                cloneTarget.set(key, clone(value, map))
            })
            return cloneTarget
        }

        const keys = type === arrayTag ? undefined : Object.keys(target)
        forEach(keys || target, (value, key) => {
            if (keys) {
                key = value
            }
            cloneTarget[key] = clone(target[key], map)
        })
        return cloneTarget
    }
</script>